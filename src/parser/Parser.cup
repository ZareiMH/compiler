package parser;

import java_cup.runtime.*;
import ast.*;

parser code {:
    protected Program root;

    void setRoot(Program p) { this.root = p; }

    public Program getRoot() { return this.root; }
:};


/* terminal and nonterminal part */

// some shit that I don't know
terminal String ID;

// symbols
terminal LCURLY, RCURLY, LBRACK, RBRACK, LPAREN, RPAREN;
terminal DOT, COMMA, COLON, SEMICOLON;

// comment
terminal SINGLELINECOMM;
terminal MULTILINECOMMSTART;
terminal MULTILINECOMMFINISH;

// strings
terminal APOST, QUOTE;

// reserved shit
terminal EXTERN, FUNCTION, BEGIN, BOOL, BREAK, CASE, CHAR;
terminal CONST, CONTINUE, DEFAULT, DOUBLE, ELSE, END;
terminal FLOAT, FOR, IF, INT, LONG, RETURN, RECORD;
terminal SIZEOF, STRING, SWITCH, OF;
terminal FOREACH, UNTIL, IN, REPEAT;
terminal AUTO, VOID, NULL;

//literals
terminal Integer INTCONST;
terminal Double REALCONST;
terminal Character CHARCONST;
terminal Boolean FALSE;
terminal Boolean TRUE;
terminal String STRINGCONST;
terminal Long LONGCONST;

// arithmatic
terminal EQ, NOTEQ, LESSEQ, LESS, GR, GREQ, ASSIGN, NOT;
terminal BITNEG, ARITHAND, LOGICAND, ARITHOR, XOR;
terminal PROD, ADD, ADDASS, SUBASS, MULTASS, DIVASS;
terminal DIV, MOD, MINUS, LOGICOR, UMINUS, UPLUS;
terminal POSTINC, POSTDEC, PREINC, PREDEC, INC, DEC;
terminal FPAREN, REFERENCE, ARRELEMENT;

// nonterminal part
nonterminal ASTNode program;
nonterminal ASTNode var_dcl;
nonterminal ASTNode func_extern;
nonterminal ASTNode struct_dec;
nonterminal ASTNode func_dcl;
nonterminal ASTNode extern_dcl;
nonterminal ASTNode type;
nonterminal ASTNode arguments;
nonterminal ASTNode block;
nonterminal ASTNode var_dcl_cnt;
nonterminal ASTNode variable;
nonterminal ASTNode expr;
nonterminal ASTNode statement;
nonterminal ASTNode assignment;
nonterminal ASTNode method_call;
nonterminal ASTNode cond_stmt;
nonterminal ASTNode loop_stmt;
nonterminal ASTNode parameters;
nonterminal ASTNode const_val;
nonterminal ASTNode conditional;
nonterminal ASTNode arguments_middle;
nonterminal ASTNode struct_dec_middle;
nonterminal ASTNode var_dcl_end;
nonterminal ASTNode block_mid;
nonterminal ASTNode cond_stmt_mid;
nonterminal ASTNode variable_mid;
nonterminal ASTNode identifier;

/*added by m.sey*/
nonterminal ASTNode literal;
nonterminal ASTNode expr_operation;


/* precedence part */
precedence left COMMA;
precedence right ASSIGN, ADDASS, SUBASS, MULTASS, DIVASS;
precedence left LOGICOR;
precedence left LOGICAND;
precedence left ARITHOR;
precedence left XOR;
precedence left ARITHAND;
precedence left EQ, NOTEQ;
precedence left LESS, LESSEQ, GR, GREQ;
precedence left ADD, MINUS;
precedence left PROD, DIV, MOD;
precedence right NOT, BITNEG, UMINUS, UPLUS, PREINC, PREDEC, SIZEOF;
precedence left POSTINC, POSTDEC, FPAREN, REFERENCE, ARRELEMENT;
precedence nonassoc LPAREN, RPAREN;

/* grammar part */
start with program;

//added for code gen
identifier ::= ID:i
    {: RESULT = new IdentifierNode(i); :};

const_val ::= INTCONST:i
    {: RESULT = new IntegerLiteralNode(i); :}
            | REALCONST:r
    {: RESULT = new FloatLiteralNode(r); :}
            | CHARCONST:c
    {: RESULT = new CharLiteralNode(c); :}
            | FALSE
    {: RESULT = new BooleanLiteralNode(false); :}
            | TRUE
    {: RESULT = new BooleanLiteralNode(true); :}
	        | STRINGCONST:s
	{: RESULT = new StringLiteralNode(s); :}
	        | LONGCONST:l
	{: RESULT = new LongLiteralNode(l); :}
	        | NULL
	{: RESULT = new BaseASTNode(NodeType.NULL_LITERAL); :};


//base grammar
program ::= var_dcl program | func_extern program | struct_dec program
			| var_dcl | func_extern | struct_dec;

func_extern ::= func_dcl | extern_dcl;

func_dcl ::= FUNCTION type identifier LPAREN arguments RPAREN SEMICOLON
			 | FUNCTION type identifier LPAREN RPAREN SEMICOLON
			 | FUNCTION type identifier LPAREN arguments RPAREN block
			 | FUNCTION type identifier LPAREN RPAREN block;

extern_dcl ::= EXTERN type identifier;

arguments ::= type identifier
			  | type identifier arguments_middle
			  | type identifier COMMA arguments
			  | type identifier arguments_middle COMMA arguments;

arguments_middle ::= LBRACK RBRACK
					 | LBRACK RBRACK arguments_middle;

type ::= INT | BOOL | FLOAT | LONG | CHAR | DOUBLE
		 | identifier | STRING | VOID | AUTO;

struct_dec ::= RECORD identifier BEGIN struct_dec_middle END RECORD;

struct_dec_middle ::= var_dcl | var_dcl struct_dec_middle;

var_dcl ::= type var_dcl_cnt var_dcl_end
			| CONST type var_dcl var_dcl_end
			| type var_dcl_cnt
			| CONST type var_dcl;

var_dcl_end ::= COMMA var_dcl_cnt var_dcl_end
				| COMMA var_dcl_cnt;

var_dcl_cnt ::= variable | variable ASSIGN expr;

block ::= BEGIN block_mid END
		  | BEGIN END;

block_mid ::= var_dcl block_mid | statement block_mid
			  | var_dcl | statement;

statement ::= assignment SEMICOLON
			  | method_call SEMICOLON
			  | cond_stmt
			  | loop_stmt
			  | RETURN expr SEMICOLON
			  | RETURN SEMICOLON
			  | BREAK SEMICOLON
			  | CONTINUE SEMICOLON;

assignment ::= variable ASSIGN expr
			   | variable ADDASS expr
			   | variable SUBASS expr
			   | variable MULTASS expr
			   | variable DIVASS expr;

method_call ::= identifier LPAREN parameters RPAREN %prec FPAREN
				| identifier LPAREN RPAREN %prec FPAREN;

parameters ::= expr | expr COMMA parameters;

cond_stmt ::= IF LPAREN expr RPAREN block
			  | IF LPAREN expr RPAREN block ELSE block
			  | SWITCH LPAREN identifier RPAREN OF COLON BEGIN DEFAULT COLON block END
			  | SWITCH LPAREN identifier RPAREN OF COLON BEGIN cond_stmt_mid DEFAULT COLON block END;

cond_stmt_mid ::= CASE INTCONST COLON block
				  | CASE INTCONST COLON block cond_stmt_mid;

loop_stmt ::= FOR LPAREN SEMICOLON expr SEMICOLON RPAREN block
			  | FOR LPAREN assignment SEMICOLON expr SEMICOLON RPAREN block
			  | FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
			  | FOR LPAREN assignment SEMICOLON expr SEMICOLON expr RPAREN block
			  | FOR LPAREN SEMICOLON expr SEMICOLON assignment RPAREN block
			  | FOR LPAREN SEMICOLON expr SEMICOLON expr RPAREN block
			  | REPEAT block UNTIL LPAREN expr RPAREN SEMICOLON
			  | FOREACH LPAREN identifier IN identifier RPAREN block;

expr ::= expr_operation
		 | LPAREN expr RPAREN
		 | method_call
		 | variable
		 | DEC variable %prec PREDEC
		 | INC variable %prec PREINC
		 | variable DEC %prec POSTDEC
		 | variable INC %prec POSTINC
		 | const_val
		 | BITNEG expr
		 | SIZEOF LPAREN type RPAREN %prec SIZEOF
		 | ADD expr %prec UPLUS
		 | MINUS expr %prec UMINUS;

variable ::= identifier | identifier variable_mid
			 | variable DOT identifier %prec REFERENCE | LPAREN variable RPAREN;

variable_mid ::= LBRACK expr RBRACK %prec ARRELEMENT
				 | LBRACK expr RBRACK variable_mid %prec ARRELEMENT;

expr_operation ::= expr:e1 ADD expr:e2
    {: RESULT = new BaseASTNode(NodeType.ADDITION);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 MINUS expr:e2
    {: RESULT = new BaseASTNode(NodeType.SUBTRACTION);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 PROD expr:e2
    {: RESULT = new BaseASTNode(NodeType.MULTIPLICATION);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 DIV expr:e2
    {: RESULT = new BaseASTNode(NodeType.DIVISION);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 MOD expr:e2
    {: RESULT = new BaseASTNode(NodeType.MOD);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 ARITHAND expr:e2
    {: RESULT = new BaseASTNode(NodeType.AREHTMATIC_AND);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 ARITHOR expr:e2
    {: RESULT = new BaseASTNode(NodeType.AREHTMATIC_OR);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 XOR expr:e2
    {: RESULT = new BaseASTNode(NodeType.XOR);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 EQ expr:e2
    {: RESULT = new BaseASTNode(NodeType.EQUAL);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 NOTEQ expr:e2
    {: RESULT = new BaseASTNode(NodeType.NOT_EQUAL);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 GREQ expr:e2
    {: RESULT = new BaseASTNode(NodeType.GREATER_THAN_OR_EQUAL);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 LESSEQ expr:e2
    {: RESULT = new BaseASTNode(NodeType.LESS_THAN_OR_EQUAL);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 GR expr:e2
    {: RESULT = new BaseASTNode(NodeType.GREATER_THAN);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 LESS expr:e2
    {: RESULT = new BaseASTNode(NodeType.LESS_THAN);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 NOT expr:e2
    {: RESULT = new BaseASTNode(NodeType.BOOLEAN_NOT);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 LOGICAND expr:e2
    {: RESULT = new BaseASTNode(NodeType.BOOLEAN_AND);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :}
                 | expr:e1 LOGICOR expr:e2
    {: RESULT = new BaseASTNode(NodeType.BOOLEAN_OR);
       RESULT.addChild(e1);
       RESULT.addChild(e2); :};


