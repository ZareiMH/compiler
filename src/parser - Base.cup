import java_cup.runtime.*;

/* terminal and non-terminal part */

// some shit that I don't know
terminal ID;

// symbols
terminal LCURLY, RCURLY, LBRACK, RBRACK, LPAREN, RPAREN;
terminal DOT, COMMA, COLON, SEMICOLON;

// comment
terminal SINGLELINECOMM;
terminal MULTILINECOMMSTART;
terminal MULTILINECOMMFINISH;

// arithmatic
terminal EQ, NOTEQ, LESSEQ, LESS, GR, GREQ, ASSIGN, NOT;
terminal BITNEG, ARITHAND, LOGICAND, ARITHOR, XOR;
terminal PROD, ADD, ADDASS, SUBASS, MULTASS, DIVASS;
terminal DIV, MOD, MINUS, LOGICOR;

// strings
terminal APOST, QUOTE;

// reserved shit
terminal EXTERN, FUNCTION, BEGIN, BOOL, BREAK, CASE, CHAR;
terminal CONST, CONTINUE, DEFAULT, DOUBLE, ELSE, END;
terminal FLOAT, FOR, IF, INT, LONG, RETURN, RECORD;
terminal SIZEOF, STRING, SWITCH, OF;
terminal FOREACH, UNTIL, IN, REPEAT;
terminal AUTO, VOID;

// numbers
terminal INTCONST, REALCONST, CHARCONST, BOOLCONST;
terminal STRINGCONST, LONGCONST;

// non-terminal part
non terminal program, var_dcl, func_extern, struct_dec;
non terminal func_dcl, extern_dcl;
non terminal type, arguments, block;
non terminal var_dcl_cnt, variable, expr;
non terminal statement, assignment, method_call, cond_stmt;
non terminal loop_stmt, parameters, binary_op, const_val;
non terminal arithmatic, conditional, arguments_middle;
non terminal struct_dec_middle, var_dcl_end, block_mid;
non terminal cond_stmt_mid, variable_mid;

/* precedence part */



/* grammar part */

start with program;

program ::= ???;

func_extern ::= func_dcl | extern_dcl;

func_dcl ::= FUNCTION type ID LPAREN arguments RPAREN SEMICOLON
			 | FUNCTION type ID LPAREN RPAREN SEMICOLON
			 | FUNCTION type ID LPAREN arguments RPAREN block
			 | FUNCTION type ID LPAREN RPAREN block;
			 
extern_dcl ::= EXTERN type ID;

arguments ::= type ID
			  | type ID arguments_middle
			  | type ID COMMA arguments
			  | type ID arguments_middle COMMA arguments;

arguments_middle ::= LBRACK RBRACK
					 | LBRACK RBRACK arguments_middle;

type ::= INT | BOOL | FLOAT | LONG | CHAR | DOUBLE
		 | ID | STRING | VOID | AUTO;

struct_dec ::= RECORD ID BEGIN struct_dec_middle END RECORD;

struct_dec_middle ::= var_dcl | var_dcl struct_dec_middle;

var_dcl ::= type var_dcl_cnt var_dcl_end
			| CONST type var_dcl var_dcl_end
			| type var_dcl_cnt
			| CONST type var_dcl;

var_dcl_end ::= COMMA var_dcl_cnt var_dcl_end
				| COMMA var_dcl_cnt;

var_dcl_cnt ::= variable | variable ASSIGN expr;

block ::= BEGIN block_mid END
		  | BEGIN END;

block_mid ::= var_dcl block_mid | statement block_mid
			  | var_dcl | statement;

statement ::= assignment SEMICOLON
			  | method_call SEMICOLON
			  | cond_stmt
			  | loop_stmt
			  | RETURN expr SEMICOLON
			  | RETURN SEMICOLON
			  | BREAK SEMICOLON
			  | CONTINUE SEMICOLON;
			  
assignment ::= variable ASSIGN expr
			   | variable ADDASS expr
			   | variable SUBASS expr
			   | variable MULTASS expr
			   | variable DIVASS expr;

method_call ::= ID LPAREN parameters RPAREN
				| ID LPAREN RPAREN;

parameters ::= expr | expr COMMA parameters;

cond_stmt ::= IF LPAREN expr RPAREN block
			  | IF LPAREN expr RPAREN block ELSE block
			  | SWITCH LPAREN ID RPAREN OF COLON BEGIN DEFAULT COLON block END
			  | SWITCH LPAREN ID RPAREN OF COLON BEGIN cond_stmt_mid DEFAULT COLON block END;

cond_stmt_mid ::= CASE INTCONST COLON block
				  | CASE INTCONST COLON block cond_stmt_mid;

loop_stmt ::= FOR LPAREN SEMICOLON expr SEMICOLON RPAREN block
			  | FOR LPAREN assignment SEMICOLON expr SEMICOLON RPAREN block
			  | FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
			  | FOR LPAREN assignment SEMICOLON expr SEMICOLON expr RPAREN block
			  | FOR LPAREN SEMICOLON expr SEMICOLON assignment RPAREN block
			  | FOR LPAREN SEMICOLON expr SEMICOLON expr RPAREN block
			  | REPEAT block UNTIL LPAREN expr RPAREN SEMICOLON
			  | FOREACH LPAREN ID IN ID RPAREN block;

expr ::= expr binary_op expr
		 | LPAREN expr RPAREN
		 | method_call
		 | variable
		 | const_val 
		 | MINUS expr
		 | BITNEG expr
		 | SIZEOF LPAREN type RPAREN;

variable ::= ID | ID variable_mid
			 | variable DOT ID
			 | BITNEG variable
			 | MINUS MINUS variable
			 | ADD ADD variable
			 | variable MINUS MINUS
			 | variable ADD ADD;
			 
variable_mid ::= LBRACK expr RBRACK | LBRACK expr RBRACK variable_mid;

binary_op ::= arithmatic | conditional;

arithmatic ::= ADD | MINUS | PROD | DIV | MOD | ARITHAND
			   | ARITHOR | XOR;

conditional ::= EQ | NOTEQ | GREQ | LESSEQ | GR | LESS
			    | LOGICAND | LOGICOR | NOT;

const_val ::= INTCONST | REALCONST | CHARCONST | BOOLCONST
			  | STRINGCONST | LONGCONST;
